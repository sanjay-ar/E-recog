{"ast":null,"code":"import { __awaiter, __generator, __values } from \"tslib\";\nimport { HttpResponse } from \"@aws-sdk/protocol-http\";\nimport { buildQueryString } from \"@aws-sdk/querystring-builder\";\nimport { requestTimeout } from \"./request-timeout\";\n\nvar FetchHttpHandler = function () {\n  function FetchHttpHandler(options) {\n    if (typeof options === \"function\") {\n      this.configProvider = options().then(function (opts) {\n        return opts || {};\n      });\n    } else {\n      this.config = options !== null && options !== void 0 ? options : {};\n      this.configProvider = Promise.resolve(this.config);\n    }\n  }\n\n  FetchHttpHandler.prototype.destroy = function () {};\n\n  FetchHttpHandler.prototype.handle = function (request, _a) {\n    var _b = _a === void 0 ? {} : _a,\n        abortSignal = _b.abortSignal;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var _c, requestTimeoutInMs, abortError, path, queryString, port, method, url, body, requestOptions, fetchRequest, raceOfPromises;\n\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            if (!!this.config) return [3, 2];\n            _c = this;\n            return [4, this.configProvider];\n\n          case 1:\n            _c.config = _d.sent();\n            _d.label = 2;\n\n          case 2:\n            requestTimeoutInMs = this.config.requestTimeout;\n\n            if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {\n              abortError = new Error(\"Request aborted\");\n              abortError.name = \"AbortError\";\n              return [2, Promise.reject(abortError)];\n            }\n\n            path = request.path;\n\n            if (request.query) {\n              queryString = buildQueryString(request.query);\n\n              if (queryString) {\n                path += \"?\".concat(queryString);\n              }\n            }\n\n            port = request.port, method = request.method;\n            url = \"\".concat(request.protocol, \"//\").concat(request.hostname).concat(port ? \":\".concat(port) : \"\").concat(path);\n            body = method === \"GET\" || method === \"HEAD\" ? undefined : request.body;\n            requestOptions = {\n              body: body,\n              headers: new Headers(request.headers),\n              method: method\n            };\n\n            if (typeof AbortController !== \"undefined\") {\n              requestOptions[\"signal\"] = abortSignal;\n            }\n\n            fetchRequest = new Request(url, requestOptions);\n            raceOfPromises = [fetch(fetchRequest).then(function (response) {\n              var e_1, _a;\n\n              var fetchHeaders = response.headers;\n              var transformedHeaders = {};\n\n              try {\n                for (var _b = __values(fetchHeaders.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                  var pair = _c.value;\n                  transformedHeaders[pair[0]] = pair[1];\n                }\n              } catch (e_1_1) {\n                e_1 = {\n                  error: e_1_1\n                };\n              } finally {\n                try {\n                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                } finally {\n                  if (e_1) throw e_1.error;\n                }\n              }\n\n              var hasReadableStream = response.body !== undefined;\n\n              if (!hasReadableStream) {\n                return response.blob().then(function (body) {\n                  return {\n                    response: new HttpResponse({\n                      headers: transformedHeaders,\n                      statusCode: response.status,\n                      body: body\n                    })\n                  };\n                });\n              }\n\n              return {\n                response: new HttpResponse({\n                  headers: transformedHeaders,\n                  statusCode: response.status,\n                  body: response.body\n                })\n              };\n            }), requestTimeout(requestTimeoutInMs)];\n\n            if (abortSignal) {\n              raceOfPromises.push(new Promise(function (resolve, reject) {\n                abortSignal.onabort = function () {\n                  var abortError = new Error(\"Request aborted\");\n                  abortError.name = \"AbortError\";\n                  reject(abortError);\n                };\n              }));\n            }\n\n            return [2, Promise.race(raceOfPromises)];\n        }\n      });\n    });\n  };\n\n  return FetchHttpHandler;\n}();\n\nexport { FetchHttpHandler };","map":{"version":3,"sources":["/Users/sanjayar/Desktop/moody-main/node_modules/@aws-sdk/client-lex-runtime-service/node_modules/@aws-sdk/fetch-http-handler/dist-es/fetch-http-handler.js"],"names":["__awaiter","__generator","__values","HttpResponse","buildQueryString","requestTimeout","FetchHttpHandler","options","configProvider","then","opts","config","Promise","resolve","prototype","destroy","handle","request","_a","_b","abortSignal","_c","requestTimeoutInMs","abortError","path","queryString","port","method","url","body","requestOptions","fetchRequest","raceOfPromises","_d","label","sent","aborted","Error","name","reject","query","concat","protocol","hostname","undefined","headers","Headers","AbortController","Request","fetch","response","e_1","fetchHeaders","transformedHeaders","entries","next","done","pair","value","e_1_1","error","return","call","hasReadableStream","blob","statusCode","status","push","onabort","race"],"mappings":"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","sourcesContent":["import { __awaiter, __generator, __values } from \"tslib\";\nimport { HttpResponse } from \"@aws-sdk/protocol-http\";\nimport { buildQueryString } from \"@aws-sdk/querystring-builder\";\nimport { requestTimeout } from \"./request-timeout\";\nvar FetchHttpHandler = (function () {\n    function FetchHttpHandler(options) {\n        if (typeof options === \"function\") {\n            this.configProvider = options().then(function (opts) { return opts || {}; });\n        }\n        else {\n            this.config = options !== null && options !== void 0 ? options : {};\n            this.configProvider = Promise.resolve(this.config);\n        }\n    }\n    FetchHttpHandler.prototype.destroy = function () {\n    };\n    FetchHttpHandler.prototype.handle = function (request, _a) {\n        var _b = _a === void 0 ? {} : _a, abortSignal = _b.abortSignal;\n        return __awaiter(this, void 0, void 0, function () {\n            var _c, requestTimeoutInMs, abortError, path, queryString, port, method, url, body, requestOptions, fetchRequest, raceOfPromises;\n            return __generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0:\n                        if (!!this.config) return [3, 2];\n                        _c = this;\n                        return [4, this.configProvider];\n                    case 1:\n                        _c.config = _d.sent();\n                        _d.label = 2;\n                    case 2:\n                        requestTimeoutInMs = this.config.requestTimeout;\n                        if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {\n                            abortError = new Error(\"Request aborted\");\n                            abortError.name = \"AbortError\";\n                            return [2, Promise.reject(abortError)];\n                        }\n                        path = request.path;\n                        if (request.query) {\n                            queryString = buildQueryString(request.query);\n                            if (queryString) {\n                                path += \"?\".concat(queryString);\n                            }\n                        }\n                        port = request.port, method = request.method;\n                        url = \"\".concat(request.protocol, \"//\").concat(request.hostname).concat(port ? \":\".concat(port) : \"\").concat(path);\n                        body = method === \"GET\" || method === \"HEAD\" ? undefined : request.body;\n                        requestOptions = {\n                            body: body,\n                            headers: new Headers(request.headers),\n                            method: method,\n                        };\n                        if (typeof AbortController !== \"undefined\") {\n                            requestOptions[\"signal\"] = abortSignal;\n                        }\n                        fetchRequest = new Request(url, requestOptions);\n                        raceOfPromises = [\n                            fetch(fetchRequest).then(function (response) {\n                                var e_1, _a;\n                                var fetchHeaders = response.headers;\n                                var transformedHeaders = {};\n                                try {\n                                    for (var _b = __values(fetchHeaders.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                                        var pair = _c.value;\n                                        transformedHeaders[pair[0]] = pair[1];\n                                    }\n                                }\n                                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                                finally {\n                                    try {\n                                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                                    }\n                                    finally { if (e_1) throw e_1.error; }\n                                }\n                                var hasReadableStream = response.body !== undefined;\n                                if (!hasReadableStream) {\n                                    return response.blob().then(function (body) { return ({\n                                        response: new HttpResponse({\n                                            headers: transformedHeaders,\n                                            statusCode: response.status,\n                                            body: body,\n                                        }),\n                                    }); });\n                                }\n                                return {\n                                    response: new HttpResponse({\n                                        headers: transformedHeaders,\n                                        statusCode: response.status,\n                                        body: response.body,\n                                    }),\n                                };\n                            }),\n                            requestTimeout(requestTimeoutInMs),\n                        ];\n                        if (abortSignal) {\n                            raceOfPromises.push(new Promise(function (resolve, reject) {\n                                abortSignal.onabort = function () {\n                                    var abortError = new Error(\"Request aborted\");\n                                    abortError.name = \"AbortError\";\n                                    reject(abortError);\n                                };\n                            }));\n                        }\n                        return [2, Promise.race(raceOfPromises)];\n                }\n            });\n        });\n    };\n    return FetchHttpHandler;\n}());\nexport { FetchHttpHandler };\n"]},"metadata":{},"sourceType":"module"}