{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n/*\n * Copyright 2017-2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n *     http://aws.amazon.com/apache2.0/\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n\n\nimport booleanClockwise from '@turf/boolean-clockwise';\nexport function validateCoordinates(lng, lat) {\n  if (!Number.isFinite(lng) || !Number.isFinite(lat)) {\n    throw new Error(\"Invalid coordinates: [\" + lng + \",\" + lat + \"]\");\n  }\n\n  if (lat < -90 || 90 < lat) {\n    throw new Error('Latitude must be between -90 and 90 degrees inclusive.');\n  } else if (lng < -180 || 180 < lng) {\n    throw new Error('Longitude must be between -180 and 180 degrees inclusive.');\n  }\n}\nexport function validateGeofenceId(geofenceId) {\n  var geofenceIdRegex = /^[-._\\p{L}\\p{N}]+$/iu; // Check if geofenceId is valid\n\n  if (!geofenceIdRegex.test(geofenceId)) {\n    throw new Error(\"Invalid geofenceId: '\" + geofenceId + \"' - IDs can only contain alphanumeric characters, hyphens, underscores and periods.\");\n  }\n}\nexport function validateLinearRing(linearRing, geofenceId) {\n  var errorPrefix = geofenceId ? geofenceId + \": \" : ''; // Validate LinearRing size, must be at least 4 points\n\n  if (linearRing.length < 4) {\n    throw new Error(errorPrefix + \"LinearRing must contain 4 or more coordinates.\");\n  } // Validate all coordinates are valid, error with which ones are bad\n\n\n  var badCoordinates = [];\n  linearRing.forEach(function (coordinates) {\n    try {\n      validateCoordinates(coordinates[0], coordinates[1]);\n    } catch (error) {\n      badCoordinates.push({\n        coordinates: coordinates,\n        error: error.message\n      });\n    }\n  });\n\n  if (badCoordinates.length > 0) {\n    throw new Error(errorPrefix + \"One or more of the coordinates in the Polygon LinearRing are not valid: \" + JSON.stringify(badCoordinates));\n  } // Validate first and last coordinates are the same\n\n\n  var _a = __read(linearRing[0], 2),\n      lngA = _a[0],\n      latA = _a[1];\n\n  var _b = __read(linearRing[linearRing.length - 1], 2),\n      lngB = _b[0],\n      latB = _b[1];\n\n  if (lngA !== lngB || latA !== latB) {\n    throw new Error(errorPrefix + \"LinearRing's first and last coordinates are not the same\");\n  }\n\n  if (booleanClockwise(linearRing)) {\n    throw new Error(errorPrefix + \"LinearRing coordinates must be wound counterclockwise\");\n  }\n}\nexport function validatePolygon(polygon, geofenceId) {\n  var errorPrefix = geofenceId ? geofenceId + \": \" : '';\n\n  if (!Array.isArray(polygon)) {\n    throw new Error(errorPrefix + \"Polygon is of incorrect structure. It should be an array of LinearRings\");\n  }\n\n  if (polygon.length < 1) {\n    throw new Error(errorPrefix + \"Polygon must have a single LinearRing array.\");\n  }\n\n  if (polygon.length > 1) {\n    throw new Error(errorPrefix + \"Polygon must have a single LinearRing array. Note: We do not currently support polygons with holes, multipolygons, polygons that are wound clockwise, or that cross the antimeridian.\");\n  }\n\n  var verticesCount = polygon.reduce(function (prev, linearRing) {\n    return prev + linearRing.length;\n  }, 0);\n\n  if (verticesCount > 1000) {\n    throw new Error(errorPrefix + \"Polygon has more than the maximum 1000 vertices.\");\n  }\n\n  polygon.forEach(function (linearRing) {\n    validateLinearRing(linearRing, geofenceId);\n  });\n}\nexport function validateGeofencesInput(geofences) {\n  var geofenceIds = {};\n  geofences.forEach(function (geofence) {\n    // verify all required properties are present\n    // Validate geofenceId exists\n    if (!geofence.geofenceId) {\n      throw new Error(\"Geofence '\" + geofence + \"' is missing geofenceId\");\n    }\n\n    var geofenceId = geofence.geofenceId;\n    validateGeofenceId(geofenceId); // Validate geofenceId is unique\n\n    if (geofenceIds[geofenceId]) {\n      throw new Error(\"Duplicate geofenceId: \" + geofenceId);\n    } else {\n      geofenceIds[geofenceId] = true;\n    } // Validate geometry exists\n\n\n    if (!geofence.geometry) {\n      throw new Error(\"Geofence '\" + geofenceId + \"' is missing geometry\");\n    }\n\n    var geometry = geofence.geometry; // Validate polygon exists\n\n    if (!geometry.polygon) {\n      throw new Error(\"Geofence '\" + geofenceId + \"' is missing geometry.polygon\");\n    }\n\n    var polygon = geometry.polygon; // Validate polygon length and structure\n\n    try {\n      validatePolygon(polygon, geofenceId);\n    } catch (error) {\n      if (error.message.includes('Polygon has more than the maximum 1000 vertices.')) {\n        throw new Error(\"Geofence '\" + geofenceId + \"' has more than the maximum of 1000 vertices\");\n      }\n    } // Validate LinearRing length, structure, and coordinates\n\n\n    var _a = __read(polygon, 1),\n        linearRing = _a[0];\n\n    validateLinearRing(linearRing, geofenceId);\n  });\n}\nexport function mapSearchOptions(options, locationServiceInput) {\n  var locationServiceModifiedInput = __assign({}, locationServiceInput);\n\n  locationServiceModifiedInput.FilterCountries = options.countries;\n  locationServiceModifiedInput.MaxResults = options.maxResults;\n\n  if (options.searchIndexName) {\n    locationServiceModifiedInput.IndexName = options.searchIndexName;\n  }\n\n  if (options['biasPosition'] && options['searchAreaConstraints']) {\n    throw new Error('BiasPosition and SearchAreaConstraints are mutually exclusive, please remove one or the other from the options object');\n  }\n\n  if (options['biasPosition']) {\n    locationServiceModifiedInput.BiasPosition = options['biasPosition'];\n  }\n\n  if (options['searchAreaConstraints']) {\n    locationServiceModifiedInput.FilterBBox = options['searchAreaConstraints'];\n  }\n\n  return locationServiceModifiedInput;\n}","map":{"version":3,"sources":["../src/util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\n/*\n * Copyright 2017-2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n *     http://aws.amazon.com/apache2.0/\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\nimport booleanClockwise from '@turf/boolean-clockwise';\nexport function validateCoordinates(lng, lat) {\n    if (!Number.isFinite(lng) || !Number.isFinite(lat)) {\n        throw new Error(\"Invalid coordinates: [\" + lng + \",\" + lat + \"]\");\n    }\n    if (lat < -90 || 90 < lat) {\n        throw new Error('Latitude must be between -90 and 90 degrees inclusive.');\n    }\n    else if (lng < -180 || 180 < lng) {\n        throw new Error('Longitude must be between -180 and 180 degrees inclusive.');\n    }\n}\nexport function validateGeofenceId(geofenceId) {\n    var geofenceIdRegex = /^[-._\\p{L}\\p{N}]+$/iu;\n    // Check if geofenceId is valid\n    if (!geofenceIdRegex.test(geofenceId)) {\n        throw new Error(\"Invalid geofenceId: '\" + geofenceId + \"' - IDs can only contain alphanumeric characters, hyphens, underscores and periods.\");\n    }\n}\nexport function validateLinearRing(linearRing, geofenceId) {\n    var errorPrefix = geofenceId ? geofenceId + \": \" : '';\n    // Validate LinearRing size, must be at least 4 points\n    if (linearRing.length < 4) {\n        throw new Error(errorPrefix + \"LinearRing must contain 4 or more coordinates.\");\n    }\n    // Validate all coordinates are valid, error with which ones are bad\n    var badCoordinates = [];\n    linearRing.forEach(function (coordinates) {\n        try {\n            validateCoordinates(coordinates[0], coordinates[1]);\n        }\n        catch (error) {\n            badCoordinates.push({ coordinates: coordinates, error: error.message });\n        }\n    });\n    if (badCoordinates.length > 0) {\n        throw new Error(errorPrefix + \"One or more of the coordinates in the Polygon LinearRing are not valid: \" + JSON.stringify(badCoordinates));\n    }\n    // Validate first and last coordinates are the same\n    var _a = __read(linearRing[0], 2), lngA = _a[0], latA = _a[1];\n    var _b = __read(linearRing[linearRing.length - 1], 2), lngB = _b[0], latB = _b[1];\n    if (lngA !== lngB || latA !== latB) {\n        throw new Error(errorPrefix + \"LinearRing's first and last coordinates are not the same\");\n    }\n    if (booleanClockwise(linearRing)) {\n        throw new Error(errorPrefix + \"LinearRing coordinates must be wound counterclockwise\");\n    }\n}\nexport function validatePolygon(polygon, geofenceId) {\n    var errorPrefix = geofenceId ? geofenceId + \": \" : '';\n    if (!Array.isArray(polygon)) {\n        throw new Error(errorPrefix + \"Polygon is of incorrect structure. It should be an array of LinearRings\");\n    }\n    if (polygon.length < 1) {\n        throw new Error(errorPrefix + \"Polygon must have a single LinearRing array.\");\n    }\n    if (polygon.length > 1) {\n        throw new Error(errorPrefix + \"Polygon must have a single LinearRing array. Note: We do not currently support polygons with holes, multipolygons, polygons that are wound clockwise, or that cross the antimeridian.\");\n    }\n    var verticesCount = polygon.reduce(function (prev, linearRing) { return prev + linearRing.length; }, 0);\n    if (verticesCount > 1000) {\n        throw new Error(errorPrefix + \"Polygon has more than the maximum 1000 vertices.\");\n    }\n    polygon.forEach(function (linearRing) {\n        validateLinearRing(linearRing, geofenceId);\n    });\n}\nexport function validateGeofencesInput(geofences) {\n    var geofenceIds = {};\n    geofences.forEach(function (geofence) {\n        // verify all required properties are present\n        // Validate geofenceId exists\n        if (!geofence.geofenceId) {\n            throw new Error(\"Geofence '\" + geofence + \"' is missing geofenceId\");\n        }\n        var geofenceId = geofence.geofenceId;\n        validateGeofenceId(geofenceId);\n        // Validate geofenceId is unique\n        if (geofenceIds[geofenceId]) {\n            throw new Error(\"Duplicate geofenceId: \" + geofenceId);\n        }\n        else {\n            geofenceIds[geofenceId] = true;\n        }\n        // Validate geometry exists\n        if (!geofence.geometry) {\n            throw new Error(\"Geofence '\" + geofenceId + \"' is missing geometry\");\n        }\n        var geometry = geofence.geometry;\n        // Validate polygon exists\n        if (!geometry.polygon) {\n            throw new Error(\"Geofence '\" + geofenceId + \"' is missing geometry.polygon\");\n        }\n        var polygon = geometry.polygon;\n        // Validate polygon length and structure\n        try {\n            validatePolygon(polygon, geofenceId);\n        }\n        catch (error) {\n            if (error.message.includes('Polygon has more than the maximum 1000 vertices.')) {\n                throw new Error(\"Geofence '\" + geofenceId + \"' has more than the maximum of 1000 vertices\");\n            }\n        }\n        // Validate LinearRing length, structure, and coordinates\n        var _a = __read(polygon, 1), linearRing = _a[0];\n        validateLinearRing(linearRing, geofenceId);\n    });\n}\nexport function mapSearchOptions(options, locationServiceInput) {\n    var locationServiceModifiedInput = __assign({}, locationServiceInput);\n    locationServiceModifiedInput.FilterCountries = options.countries;\n    locationServiceModifiedInput.MaxResults = options.maxResults;\n    if (options.searchIndexName) {\n        locationServiceModifiedInput.IndexName = options.searchIndexName;\n    }\n    if (options['biasPosition'] && options['searchAreaConstraints']) {\n        throw new Error('BiasPosition and SearchAreaConstraints are mutually exclusive, please remove one or the other from the options object');\n    }\n    if (options['biasPosition']) {\n        locationServiceModifiedInput.BiasPosition = options['biasPosition'];\n    }\n    if (options['searchAreaConstraints']) {\n        locationServiceModifiedInput.FilterBBox = options['searchAreaConstraints'];\n    }\n    return locationServiceModifiedInput;\n}\n//# sourceMappingURL=util.js.map"]},"metadata":{},"sourceType":"module"}