{"ast":null,"code":"/*\n * Copyright 2017-2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n *     http://aws.amazon.com/apache2.0/\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport Observable from 'zen-observable-ts';\nimport { ConnectionState } from '../types/PubSub';\nimport { ReachabilityMonitor } from './ReachabilityMonitor';\nexport var CONNECTION_CHANGE = {\n  KEEP_ALIVE_MISSED: {\n    keepAliveState: 'unhealthy'\n  },\n  KEEP_ALIVE: {\n    keepAliveState: 'healthy'\n  },\n  CONNECTION_ESTABLISHED: {\n    connectionState: 'connected'\n  },\n  CONNECTION_FAILED: {\n    intendedConnectionState: 'disconnected',\n    connectionState: 'disconnected'\n  },\n  CLOSING_CONNECTION: {\n    intendedConnectionState: 'disconnected'\n  },\n  OPENING_CONNECTION: {\n    intendedConnectionState: 'connected',\n    connectionState: 'connecting'\n  },\n  CLOSED: {\n    connectionState: 'disconnected'\n  },\n  ONLINE: {\n    networkState: 'connected'\n  },\n  OFFLINE: {\n    networkState: 'disconnected'\n  }\n};\n\nvar ConnectionStateMonitor =\n/** @class */\nfunction () {\n  function ConnectionStateMonitor() {\n    var _this = this;\n\n    this._networkMonitoringSubscription = undefined;\n    this._linkedConnectionState = {\n      networkState: 'connected',\n      connectionState: 'disconnected',\n      intendedConnectionState: 'disconnected',\n      keepAliveState: 'healthy'\n    };\n    this._linkedConnectionStateObservable = new Observable(function (connectionStateObserver) {\n      connectionStateObserver.next(_this._linkedConnectionState);\n      _this._linkedConnectionStateObserver = connectionStateObserver;\n    });\n  }\n  /**\n   * Turn network state monitoring on if it isn't on already\n   */\n\n\n  ConnectionStateMonitor.prototype.enableNetworkMonitoring = function () {\n    var _this = this; // Maintain the network state based on the reachability monitor\n\n\n    if (this._networkMonitoringSubscription === undefined) {\n      this._networkMonitoringSubscription = ReachabilityMonitor().subscribe(function (_a) {\n        var online = _a.online;\n\n        _this.record(online ? CONNECTION_CHANGE.ONLINE : CONNECTION_CHANGE.OFFLINE);\n      });\n    }\n  };\n  /**\n   * Turn network state monitoring off if it isn't off already\n   */\n\n\n  ConnectionStateMonitor.prototype.disableNetworkMonitoring = function () {\n    var _a;\n\n    (_a = this._networkMonitoringSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n    this._networkMonitoringSubscription = undefined;\n  };\n\n  Object.defineProperty(ConnectionStateMonitor.prototype, \"connectionStateObservable\", {\n    /**\n     * Get the observable that allows us to monitor the connection state\n     *\n     * @returns {Observable<ConnectionState>} - The observable that emits ConnectionState updates\n     */\n    get: function () {\n      var _this = this;\n\n      var previous; // The linked state aggregates state changes to any of the network, connection,\n      // intendedConnection and keepAliveHealth. Some states will change these independent\n      // states without changing the overall connection state.\n      // After translating from linked states to ConnectionState, then remove any duplicates\n\n      return this._linkedConnectionStateObservable.map(function (value) {\n        return _this.connectionStatesTranslator(value);\n      }).filter(function (current) {\n        var toInclude = current !== previous;\n        previous = current;\n        return toInclude;\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /*\n   * Updates local connection state and emits the full state to the observer.\n   */\n\n  ConnectionStateMonitor.prototype.record = function (statusUpdates) {\n    // Maintain the network monitor\n    if (statusUpdates.intendedConnectionState === 'connected') {\n      this.enableNetworkMonitoring();\n    } else if (statusUpdates.intendedConnectionState === 'disconnected') {\n      this.disableNetworkMonitoring();\n    } // Maintain the socket state\n\n\n    var newSocketStatus = __assign(__assign({}, this._linkedConnectionState), statusUpdates);\n\n    this._linkedConnectionState = __assign({}, newSocketStatus);\n\n    this._linkedConnectionStateObserver.next(this._linkedConnectionState);\n  };\n  /*\n   * Translate the ConnectionState structure into a specific ConnectionState string literal union\n   */\n\n\n  ConnectionStateMonitor.prototype.connectionStatesTranslator = function (_a) {\n    var connectionState = _a.connectionState,\n        networkState = _a.networkState,\n        intendedConnectionState = _a.intendedConnectionState,\n        keepAliveState = _a.keepAliveState;\n    if (connectionState === 'connected' && networkState === 'disconnected') return ConnectionState.ConnectedPendingNetwork;\n    if (connectionState === 'connected' && intendedConnectionState === 'disconnected') return ConnectionState.ConnectedPendingDisconnect;\n    if (connectionState === 'disconnected' && intendedConnectionState === 'connected' && networkState === 'disconnected') return ConnectionState.ConnectionDisruptedPendingNetwork;\n    if (connectionState === 'disconnected' && intendedConnectionState === 'connected') return ConnectionState.ConnectionDisrupted;\n    if (connectionState === 'connected' && keepAliveState === 'unhealthy') return ConnectionState.ConnectedPendingKeepAlive; // All remaining states directly correspond to the connection state\n\n    if (connectionState === 'connecting') return ConnectionState.Connecting;\n    if (connectionState === 'disconnected') return ConnectionState.Disconnected;\n    return ConnectionState.Connected;\n  };\n\n  return ConnectionStateMonitor;\n}();\n\nexport { ConnectionStateMonitor };","map":{"version":3,"sources":["../../src/utils/ConnectionStateMonitor.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2017-2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n *     http://aws.amazon.com/apache2.0/\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport Observable from 'zen-observable-ts';\nimport { ConnectionState } from '../types/PubSub';\nimport { ReachabilityMonitor } from './ReachabilityMonitor';\nexport var CONNECTION_CHANGE = {\n    KEEP_ALIVE_MISSED: { keepAliveState: 'unhealthy' },\n    KEEP_ALIVE: { keepAliveState: 'healthy' },\n    CONNECTION_ESTABLISHED: { connectionState: 'connected' },\n    CONNECTION_FAILED: {\n        intendedConnectionState: 'disconnected',\n        connectionState: 'disconnected',\n    },\n    CLOSING_CONNECTION: { intendedConnectionState: 'disconnected' },\n    OPENING_CONNECTION: {\n        intendedConnectionState: 'connected',\n        connectionState: 'connecting',\n    },\n    CLOSED: { connectionState: 'disconnected' },\n    ONLINE: { networkState: 'connected' },\n    OFFLINE: { networkState: 'disconnected' },\n};\nvar ConnectionStateMonitor = /** @class */ (function () {\n    function ConnectionStateMonitor() {\n        var _this = this;\n        this._networkMonitoringSubscription = undefined;\n        this._linkedConnectionState = {\n            networkState: 'connected',\n            connectionState: 'disconnected',\n            intendedConnectionState: 'disconnected',\n            keepAliveState: 'healthy',\n        };\n        this._linkedConnectionStateObservable =\n            new Observable(function (connectionStateObserver) {\n                connectionStateObserver.next(_this._linkedConnectionState);\n                _this._linkedConnectionStateObserver = connectionStateObserver;\n            });\n    }\n    /**\n     * Turn network state monitoring on if it isn't on already\n     */\n    ConnectionStateMonitor.prototype.enableNetworkMonitoring = function () {\n        var _this = this;\n        // Maintain the network state based on the reachability monitor\n        if (this._networkMonitoringSubscription === undefined) {\n            this._networkMonitoringSubscription = ReachabilityMonitor().subscribe(function (_a) {\n                var online = _a.online;\n                _this.record(online ? CONNECTION_CHANGE.ONLINE : CONNECTION_CHANGE.OFFLINE);\n            });\n        }\n    };\n    /**\n     * Turn network state monitoring off if it isn't off already\n     */\n    ConnectionStateMonitor.prototype.disableNetworkMonitoring = function () {\n        var _a;\n        (_a = this._networkMonitoringSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n        this._networkMonitoringSubscription = undefined;\n    };\n    Object.defineProperty(ConnectionStateMonitor.prototype, \"connectionStateObservable\", {\n        /**\n         * Get the observable that allows us to monitor the connection state\n         *\n         * @returns {Observable<ConnectionState>} - The observable that emits ConnectionState updates\n         */\n        get: function () {\n            var _this = this;\n            var previous;\n            // The linked state aggregates state changes to any of the network, connection,\n            // intendedConnection and keepAliveHealth. Some states will change these independent\n            // states without changing the overall connection state.\n            // After translating from linked states to ConnectionState, then remove any duplicates\n            return this._linkedConnectionStateObservable\n                .map(function (value) {\n                return _this.connectionStatesTranslator(value);\n            })\n                .filter(function (current) {\n                var toInclude = current !== previous;\n                previous = current;\n                return toInclude;\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /*\n     * Updates local connection state and emits the full state to the observer.\n     */\n    ConnectionStateMonitor.prototype.record = function (statusUpdates) {\n        // Maintain the network monitor\n        if (statusUpdates.intendedConnectionState === 'connected') {\n            this.enableNetworkMonitoring();\n        }\n        else if (statusUpdates.intendedConnectionState === 'disconnected') {\n            this.disableNetworkMonitoring();\n        }\n        // Maintain the socket state\n        var newSocketStatus = __assign(__assign({}, this._linkedConnectionState), statusUpdates);\n        this._linkedConnectionState = __assign({}, newSocketStatus);\n        this._linkedConnectionStateObserver.next(this._linkedConnectionState);\n    };\n    /*\n     * Translate the ConnectionState structure into a specific ConnectionState string literal union\n     */\n    ConnectionStateMonitor.prototype.connectionStatesTranslator = function (_a) {\n        var connectionState = _a.connectionState, networkState = _a.networkState, intendedConnectionState = _a.intendedConnectionState, keepAliveState = _a.keepAliveState;\n        if (connectionState === 'connected' && networkState === 'disconnected')\n            return ConnectionState.ConnectedPendingNetwork;\n        if (connectionState === 'connected' &&\n            intendedConnectionState === 'disconnected')\n            return ConnectionState.ConnectedPendingDisconnect;\n        if (connectionState === 'disconnected' &&\n            intendedConnectionState === 'connected' &&\n            networkState === 'disconnected')\n            return ConnectionState.ConnectionDisruptedPendingNetwork;\n        if (connectionState === 'disconnected' &&\n            intendedConnectionState === 'connected')\n            return ConnectionState.ConnectionDisrupted;\n        if (connectionState === 'connected' && keepAliveState === 'unhealthy')\n            return ConnectionState.ConnectedPendingKeepAlive;\n        // All remaining states directly correspond to the connection state\n        if (connectionState === 'connecting')\n            return ConnectionState.Connecting;\n        if (connectionState === 'disconnected')\n            return ConnectionState.Disconnected;\n        return ConnectionState.Connected;\n    };\n    return ConnectionStateMonitor;\n}());\nexport { ConnectionStateMonitor };\n//# sourceMappingURL=ConnectionStateMonitor.js.map"]},"metadata":{},"sourceType":"module"}